# AI/Copilot Usage Disclosure
Hi! If you're reading this, chances are you're curious about *how* AI tools were used in the creation of this project. I'll try to keep sections organized based on overall sub-objectives, and use a journal-like style since I'd imagine you'd want to peer into my thought processes :D

Extra context/background info: My previous projects have mostly been purely static apps with little to no data fetching, and involved using MobX instead of Redux for state management. This is my first time building an app with a larger focus on data fetching and API integration, and my first time using Redux as well. 

Here goes!

## AI Tools Used:
- *GitHub Copilot*: Used primarily for code suggestions and boilerplate generation.
- *Claude*: Used primarily for brainstorming and debugging.
- *ChatGPT*: Used primarily when Claude rate limit is hit (lol), when Claude answers appear suboptimal (feel "off") and I want a "second opinion", or when a task is too "simple" to justify using up my Claude quota (e.g. boilerplate, simple refactors).
- *Google Browser AI*: Does this count? Lol. Sometimes if I'm suspicious a LLM is hallucinating or want to tackle something that's more trouble to prompt than just to Google, I'll do a quick google search on docs or StackOverflow to verify, and occasionally the Browser AI provides pretty good summaries.

## Project Conceptualization
### Prompt: *[Paste Entire Project Requirement]*
- Reasoning: I wanted to get a high-level overview of the project requirements before diving in, and check out what the "average, standardized solution" would be in terms of layout and presentation â€” just to make sure I'm envisioning more or less the same thing.
- Outcome: Claude generated a simple homepage with a logo and an anime search bar. Very barebones and search was broken (as expected, since i didn't provide any API details), but it gave me a baseline to work against and some code to look through. Mainly it just helped me feel less intimidated about taking on this coding challenge to begin with. (Never done one before, first times are scary!)
### Prompt: Create a sample single anime page layout, given these fields available: *[Paste Response Sample from Jikan's getAnimeById]*
- Reasoning: I wanted to get a feel for how to best present the various fields available in the anime details response.
- Outcome: Claude generated a fairly clean base layout with sections for synopsis, stats, genres, studios, and trailer, which I could then further adjust in Figma.

## General Busywork
### Prompt: Convert this *[List of Enum Values]* into a TypeScript Type
- Reasoning: Sometimes it's nice to offload busywork to AI, helps me focus on higher-level tasks and cuts down on manual-typing typos
- Outcome: ChatGPT generated the TypeScript code for me, which I then copy-pasted into my codebase.
- Other Examples of Busywork Offloaded to AI:
  - Creating labels for params and putting them into an object for easier mapping in the UI (eg mapping "TV Show" to "tv" for the API call)
  - Creating TypeScript interfaces from response schema in the Jikan API docs

## CSS Theme Variable Names
### Prompt: Generate the rest for me [Paste Base Hue vars, Chroma Level vars, Lightness Level vars, and two examples of Primary theme colors]
- Reasoning: I like using variables for base "aspects" (like hue, chroma, lightness) and then deriving theme colors from those base aspects. It's a one-time templating task and repetitive in nature, practically the perfect use case for AI assistance.
- Outcome: ChatGPT generated the rest of the CSS variable names for me in `tailwindThemeColors.css`.

## Managing Typescript Types
### Prompt: *What name to give this TypeScript Type *[Paste Enums]*? 
e.g., the "type" param for "getAnimeSearch" [Enum: "tv" "movie" "ova" "special" "ona" "music" "cm" "pv" "tv_special"]
- Reasoning: I like to suffix my types with "Type" to distinguish them from class names, but I'm not about to name this "AnimeTypeType" lol.
- Outcome: ChatGPT suggested "MediaFormatType", which I then extended to AnimeMediaFormatType (in case we're supporting manga or other media types in the future)

## Automated Tests
### Prompt: [Paste Feature to Test + Relevant Typescript Interfaces]
### Full Disclosure: All test code was generated by AI.
- Reasoning: Previously, I haven't written many automated tests, as my past projects were often creative/iterative in nature and often subject to frequent changes; I reasoned the overhead of maintaining tests was greater than the benefits. However, since this project involved data fetching and state management where requirements are more concrete and less likely to change, I felt it was a good opportunity to start learning vitest. I found AI tools to be helpful in converting my thoughts of "what should be tested" into actual test code.
- Outcome: Claude and ChatGPT generated test code based on my feature descriptions and relevant typescript interfaces. I reviewed and tested the generated code to the best of my current abilities, debugged and adjusted as necessary, and learned quite a bit!

## Redux
### Prompt: [Describe Requirements Using MobX Terms + Paste Relevant Typescript Interfaces] Please help generate a Redux Toolkit Equivalent
- Reasoning: I'm pretty much completely new to Redux! That being said, I am quite familiar with state management using MobX, and going through a quick Redux tutorial (i.e. Redux Docs and telling ChatGPT to explain concepts to me) made me realize that many concepts are now more similar with the new Redux Toolkit approach (store vs rootstores, slices vs childstores etc). I found it easier to describe what I wanted in MobX terms, and have AI help me translate that into Redux Toolkit code.
- Outcome: Claude generated fairly accurate Redux Toolkit code based on my MobX-style descriptions. I then reviewed and adjusted the code as necessary to fit my project structure and naming conventions. At some point, I found this to be a really cool learning project for learning Redux (and so many other new things!), so I ended up adding note-like comments just to reinforce learning for myself.

## "Big" Components
### Prompt: [Describe Component Requirements, Let Github Copilot Handle the First Draft]
- Example Prompt: Okay, biiig project for you. Need you to, based on store.ts loading states and param, call jikanFetchAnimeSearch, then render a grid. Should render when on first load, and when a store param updates, but debounce to 250ms. If it's loading, populate with 25 skeletons (dont worry about individual card styling I'll do those later). If an error returns, just display the error message. Otherwise, render the cards of the specified page
- Reasoning: For larger components, it can feel a little mentally overwhelming to think through all the logic and structure at once. I find it helpful to let Copliot generate a first draft based on my description. It feels easier to review and adjust code than to write it from scratch sometimes.
- Outcome: Copilot generated a solid first draft for me, which I then reviewed and adjusted as necessary to fit my project structure and naming conventions.
## Going Down Rabbit Holes...
Sometimes when Claude/ChatGPT offer up curious suggestions, I end up probing further into the topic out of curiosity. Sometimes it leads to dead ends, sometimes it leads to cool discoveries. Some neat things I learned/picked up working on this project:
- ***Interfaces vs Types***: I used to strongly prefer types over interfaces in TS (they felt more "strict" to me), but after ChatGPT suggested a solution using interfaces, I ended up browsing reddit and StackOverflow threads. The conclusion I got was "it depends on the use case" (fair lol, that and intellisense supports interfaces better in some IDEs for union types). I settled on interface for large objects, considering the extend functionality might be useful (eg respose from `getAnimeFullById` vs `getAnimeById`). I eventually circled back around with Claude to my initial query: I intended to define a union of string literals for animeMediaFormats, then use that to type out (?) an object to map to label values in the UI, but Claude went "Hey, if you already know all the values beforehand, why not create a const object, THEN derive the types?" Cue `animeMediaFormats.ts`
- ***Naming Conventions***: I tried coming up with a descriptive name for jikan api calls. Started out with `fetchAllAnimeByQueryAndPage`, but I wondered if it was too verbose. ChatGPT suggested that since it's the "main" way of fetching data, a general name would be fine, and suggested `fetchAnimeList`, but I felt that would indicate it returned an array rather than a paginated response. Eventually settled on `jikanFetchAnimeSearch` since it does indicate a purpose `fetch` and it's form the `jikan` API, in case I ever need to add other APIs in the future.
- ***TypeScript Generic Types***: I used to create separate static types for similar structures, but seeing Claude suggest generic types made me curious to learn more. I ended up reading through the TS docs and prompting more about it, and it seems pretty useful for reusable React components which can work with slightly different but still similar data shapes.

## Some Final Thoughts
- Honestly, I think I trash-talked ChatGPT a bit too much in the beginning. Sometimes it actually performs better than Claude, and I find myself defaulting more to it since I don't have to worry about rate limits (GPT-4 seems to perform more or less as well as GPT-5 in my experience so far).